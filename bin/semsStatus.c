/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "semsStatus.h"
#include "semsSensorCom.h"
#include <signal.h>

/** Initialize the semsSensorTable table by defining its contents and how it's structured */

unsigned int indx;
Sensor* sensors[8];
netsnmp_table_row* rows[8];
int fd;
netsnmp_table_data_set *table_set;



void update_table(void) {
   netsnmp_table_row*  row;
   for (indx = 0; indx < 8; indx++){
	netsnmp_table_dataset_remove_and_delete_row (table_set,rows[indx]);
        row = netsnmp_create_table_data_row();
        netsnmp_table_row_add_index(row,ASN_UNSIGNED,&sensors[indx]->port,sizeof(sensors[indx]->port));	
        netsnmp_set_row_column(row,2, ASN_INTEGER,&sensors[indx]->status,sizeof(sensors[indx]->status));
        netsnmp_set_row_column(row,3, ASN_INTEGER,&sensors[indx]->type,sizeof(sensors[indx]->type));
        netsnmp_set_row_column(row,4, ASN_INTEGER,&sensors[indx]->temp,sizeof(sensors[indx]->temp));
        netsnmp_set_row_column(row,5, ASN_UNSIGNED,&sensors[indx]->rh,sizeof(sensors[indx]->rh));
        netsnmp_set_row_column(row,6, ASN_OCTET_STR,sensors[indx]->location,strlen(sensors[indx]->location));
        netsnmp_mark_row_column_writable(row, 2, 0);        // make writable via SETs
        netsnmp_table_dataset_add_row(table_set, row);
	rows[indx] = row;
   }
}



void
initialize_table_semsSensorTable(void)
{
    const oid semsSensorTable_oid[] = {1,3,6,1,4,1,40790,1,1,1,1};
    netsnmp_table_row *row;

    /* create the table structure itself */
    table_set = netsnmp_create_table_data_set("semsSensorTable");

    /* comment this out or delete if you don't support creation of new rows */
    table_set->allow_creation = 1;



    /***************************************************
     * Adding indexes
     */
    DEBUGMSGTL(("initialize_table_semsSensorTable",
                "adding indexes to table semsSensorTable\n"));
    netsnmp_table_set_add_indexes(table_set,
                           ASN_UNSIGNED,  /* index: semsSensorPortNbr */
                           0);

    DEBUGMSGTL(("initialize_table_semsSensorTable",
                "adding column types to table semsSensorTable\n"));
    netsnmp_table_set_multi_add_default_row(table_set,
                                            COLUMN_SEMSSENSORPORTNBR, ASN_UNSIGNED, 0,
                                            NULL, 0,
                                            COLUMN_SEMSSENSORSTAUTS, ASN_INTEGER, 0,
                                            NULL, 0,
                                            COLUMN_SEMSSENSORTYPE, ASN_INTEGER, 0,
                                            NULL, 0,
                                            COLUMN_SEMSSENSORTEMP, ASN_INTEGER, 0,
                                            NULL, 0,
                                            COLUMN_SEMSSENSORRH, ASN_UNSIGNED, 0,
                                            NULL, 0,
                                            COLUMN_SEMSSENSORLOC, ASN_OCTET_STR, 1,
                                            NULL, 0,
                              0);

    /* registering the table with the master agent */
    /* note: if you don't need a subhandler to deal with any aspects
       of the request, change semsSensorTable_handler to "NULL" */
    netsnmp_register_table_data_set(netsnmp_create_handler_registration("semsSensorTable", semsSensorTable_handler,
                                                        semsSensorTable_oid,
                                                        OID_LENGTH(semsSensorTable_oid),
                                                        HANDLER_CAN_RWRITE),
                            table_set, NULL);

   for (indx = 0; indx < 8; indx++){
	Sensor* t = (Sensor*)malloc(sizeof(Sensor));
	Sensor_init(fd,indx,t);
	sensors[indx] = t;
   	row = netsnmp_create_table_data_row();
   	netsnmp_table_row_add_index(row,ASN_UNSIGNED,&sensors[indx]->port,sizeof(sensors[indx]->port));
   	netsnmp_set_row_column(row,2, ASN_INTEGER,&sensors[indx]->status,sizeof(sensors[indx]->status));
	netsnmp_set_row_column(row,3, ASN_INTEGER,&sensors[indx]->type,sizeof(sensors[indx]->type));
	netsnmp_set_row_column(row,4, ASN_INTEGER,&sensors[indx]->temp,sizeof(sensors[indx]->temp));
	netsnmp_set_row_column(row,5, ASN_UNSIGNED,&sensors[indx]->rh,sizeof(sensors[indx]->rh));
        netsnmp_set_row_column(row,6, ASN_OCTET_STR,sensors[indx]->location,strlen(sensors[indx]->location)); 
   	netsnmp_mark_row_column_writable(row, 2, 0);        // make writable via SETs 
   	netsnmp_table_dataset_add_row(table_set, row);
	rows[indx] = row;
   }
   netsnmp_register_auto_data_table(table_set, NULL);
}

updateData(int sig) {
  //netsnmp_table_dataset_delete_all_data(table_set->default_row); 
  for(indx = 0; indx < 8; indx++) 
	semsUpdateSensor(fd,sensors[indx]);
  update_table();
  alarm(30);
}


/** Initializes the semsStatus module */
void
init_semsStatus(void)
{

  /* here we initialize all the tables we're planning on supporting */
    fd = semsInitComs();
    if (fd < 0)
	exit(1); 
    initialize_table_semsSensorTable();
    if (signal(SIGALRM, updateData) == SIG_ERR){
 	 printf("\ncan't catch sigalarm\n");
 	 exit(1);
    }
   alarm(30);
}

/** handles requests for the semsSensorTable table, if anything else needs to be done */
int
semsSensorTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {
    /* perform anything here that you need to do.  The requests have
       already been processed by the master table_dataset handler, but
       this gives you chance to act on the request in some other way
       if need be. */
    return SNMP_ERR_NOERROR;
}


